<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    jvm |  叶枫
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

</head>

</html>

<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-jvm"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  jvm
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/11/26/jvm/" class="article-date">
  <time datetime="2020-11-26T08:46:06.000Z" itemprop="datePublished">2020-11-26</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">3.6k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">13 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="类装载"><a href="#类装载" class="headerlink" title="类装载"></a>类装载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.运行时常量池：在方法区中，每个类型都对应一个常量池，存放该类型所用到的所有常量，常量池中存储了诸如文字字符串、<span class="keyword">final</span>变量值、类名和方法名常量。</span><br><span class="line"><span class="number">2</span>.字段信息：字段信息存放类中声明的每一个字段的信息，包括字段的名、类型、修饰符。</span><br><span class="line"><span class="number">3</span>.方法信息：类中声明的每一个方法的信息，包括方法名、返回值类型、参数类型、修饰符、异常、方法的字节码。</span><br><span class="line">(在编译的时候，就已经将方法的局部变量、操作数栈大小等确定并存放在字节码中，在装载的时候，随着类一起装入方法区。) </span><br><span class="line"><span class="number">4</span>.静态变量：类变量，类的所有实例都共享，我们只需知道，在方法区有个静态区，静态区专门存放静态变量和静态块。</span><br><span class="line"><span class="number">5</span>.到类classloader的引用：到该类的类装载器的引用。 </span><br><span class="line"><span class="number">6</span>.到类<span class="class"><span class="keyword">class</span> 的引用：虚拟机为每一个被装载的类型创建一个<span class="title">class</span>实例，用来代表这个被装载的类。</span></span><br></pre></td></tr></table></figure>

<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">一个方法在执行时有会有一个栈帧</span><br><span class="line">栈帧里面包含了局部变量表、操作数据栈、动态连接</span><br><span class="line"></span><br><span class="line">1、局部变量表里存放的是栈帧的方法里头的局部变量。存放基本类型、引用类型</span><br><span class="line">2、操作数据栈存放的是局部变量的值，</span><br><span class="line">3、动态连接</span><br><span class="line">Person person = new Person() 在解析的时候,我们会用包名字符串com.xxx.Person进行符号引用</span><br><span class="line">当在jvm解析的时候,会将包名转换为地址。进行引用，称之为直接引用</span><br><span class="line">Person p = new Worker()</span><br><span class="line">Person pp = new Student()</span><br><span class="line">当多态的情况时,每次运行都会去转换不同的地址。</span><br><span class="line">而如果是单个对象的话，地址始终指向同一个引用变量名</span><br><span class="line">4、出现栈溢出的情况时，当栈里面的方法栈帧过多导致栈溢出</span><br><span class="line">5、本地方法栈跟虚拟机栈是一样的，只是调用了操作系统的方法</span><br></pre></td></tr></table></figure>

<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、jvm区域最大的一块,在jvm启动时就已经创建完毕了</span><br><span class="line">2、堆允许物理空间不连续，只要逻辑连续即可。比如list集合的对象可以分开放，最后连在一起即可</span><br><span class="line">3、堆分为 新生代 老生代 = 1：2</span><br><span class="line">4、新生代一般使用率在百分之90 在使时 只能使用一个eden和一个s区间（s0或s1）为了清理碎片</span><br><span class="line">5、新生代存放的 1、生命周期比较短的对象例如 普通对象，老生代存放着map list内存比较大的对象,</span><br><span class="line">当eden区中的对象第一次被回收仍然存活的话，将会转换到s区,当再次在s区回收此对象仍然存活年龄则加一,当到达一定的年龄的时候，将会转入到老生代里</span><br><span class="line">6、当处理s0的对象后,不连续了将其复制到s1转换为连接的对象，为了清理碎片化。提供空间使用</span><br></pre></td></tr></table></figure>

<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、存放的是类的元数据（描述类的信息）,常量池,方法信息（方法代码）</span><br><span class="line">2、假设person.say方法流程</span><br><span class="line">首先在堆创建一个new Person对象转换为地址直接引用，到虚拟机栈的引用变量名person上，再调用方法区的person.say方法</span><br></pre></td></tr></table></figure>

<h3 id="栈、堆"><a href="#栈、堆" class="headerlink" title="栈、堆"></a>栈、堆</h3><p>栈存放着引用对象名，指向堆的对象</p>
<p>堆存放着new的对象和数组，当堆内存中的实体没有指向的时候，jvm会自动回收该对象。</p>
<h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();这种属于强引用</span><br><span class="line">1、强引用在什么时候失效呢？</span><br><span class="line">public void <span class="function"><span class="title">method</span></span>()&#123;</span><br><span class="line">	Object obj = new Object();</span><br><span class="line">  &#125;</span><br><span class="line">当方法结束时,强引用会gc回收掉 或者把引用变量名赋值为空时等待gc去进行回收</span><br><span class="line">强引用回收除了以上俩种会进行回收,其他则不会。</span><br><span class="line">即使堆的内存满了,则会报Java heap space, gc也不会进行回收强引用</span><br></pre></td></tr></table></figure>

<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>1、当堆的内容满的时候，gc会进行回收掉软引用对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoftObject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmReference</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//软引用-&gt;弱引用-&gt;虚引用 调用接口</span></span><br><span class="line">        SoftReference&lt;SoftObject&gt; reference = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> SoftObject());</span><br><span class="line">        List&lt;Byte[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">""</span>);</span><br><span class="line">                <span class="keyword">if</span>(reference.get()==<span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">"软引用已被回收"</span>);</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(reference.get()!=<span class="keyword">null</span>)</span><br><span class="line">                list.add(<span class="keyword">new</span> Byte[<span class="number">1024</span>*<span class="number">1024</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5CTypora%5C%E5%9B%BE%E7%89%87%5Cimage-20210719141722765.png" alt="image-20210719141722765"></p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#无论java内存是否充足都会回收弱引用对象</span></span><br></pre></td></tr></table></figure>

<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建虚引用时,还需要队列接口。</span></span><br><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();<span class="comment">//引用队列</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object();<span class="comment">//强引用对象</span></span><br><span class="line">PhantomReference&lt;T&gt; reference = <span class="keyword">new</span> PhantomReference&lt;T&gt;(<span class="string">"这里是强应用对象"</span>,queue);<span class="comment">//创建虚引用</span></span><br><span class="line"><span class="comment">//当将强引用对象置为空时,并且提醒gc进行回收.虚引用将会把强引用对象放入到队列中</span></span><br><span class="line">obj = <span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line"><span class="comment">//gc-&gt;虚引用-&gt;入队-&gt;出队</span></span><br><span class="line">System.out.println(reference.poll)<span class="comment">//进行出队操作，这里将会出队于强引用对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当强用使用了finalize方法,虚引用将会延长出列.</span></span><br><span class="line">finalize();<span class="comment">//在调用System.gc()时使用</span></span><br></pre></td></tr></table></figure>

<h3 id="主动使用静态成员的问题"><a href="#主动使用静态成员的问题" class="headerlink" title="主动使用静态成员的问题"></a>主动使用静态成员的问题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#当一个类初始化一个变量时,静态代码会被加载,如果加上final static 的话将会变成一个常量.则静态代码将不会运行。</span></span><br><span class="line"><span class="comment">#final static 称之为常量</span></span><br><span class="line">1、常量的产生时间</span><br><span class="line">	时间：编译时间</span><br><span class="line">	地点(调用这个常量的方法 所在的类的)常量池</span><br><span class="line">2、主动初始化 new一个对象 或者调用静态变量的以及调用静态的方法 则静态代码会运行。其他情况将不会运行</span><br></pre></td></tr></table></figure>

<h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">jvm自带的加载器</span><br><span class="line">1、根加载器 Bootstap</span><br><span class="line">2、扩展类加载器 Extension</span><br><span class="line">3、系统加载器 app 加载classpath的classloader</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过系统加载器往上抛,从根加载器找,找不到再往下找.直到系统加载器都找不到的话就报出无法加载xxx.class类</span></span><br><span class="line"></span><br><span class="line">1、数组的加载器类型和数组元素的加载类型 是系统加载类型相同的 object</span><br><span class="line">2、原生类型的数组 是没有类加载器的 <span class="comment">#int[]</span></span><br><span class="line">3、如果加载为null 可能是原生类型 也可能是根加载器bootstrap</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置自定义加载器的话,将类继承于ClassLoader抽象类.</span></span><br><span class="line"><span class="comment">#首先加载lodeClass-&gt;findClass</span></span><br><span class="line"><span class="comment">#findclass需要重写返回byte[] 将Class放在硬盘的某个地方下,通过inputStream输入流来获取到文件流,再将文件流到输出到outputStream,通过输出流获取出byte字节进行返回。也可以存放在http中进行读取,取出方式也是一样的。</span></span><br><span class="line"><span class="comment">#要实现自定义加载时,需要把编译的class类删掉。防止进行编译,通过上面的方法就可以读取出自定义的加载器.</span></span><br><span class="line"><span class="comment">#这里读取多次同一个classloader的hashcode一致的问题,是因为编译文件是一致所以不会进行改变</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The parent class loader for delegation</span></span><br><span class="line"><span class="comment">// Note: VM hardcoded the offset of this field, thus all new fields</span></span><br><span class="line"><span class="comment">// must be added *after* it.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent; <span class="comment">//这个是委托父类加载器</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">               	 *当父类加载器不为空时,会找到当前父类加载器的父母类加载进行查找。</span></span><br><span class="line"><span class="comment">               	 直到根加载器</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//这里为根加载器直接查,这里会查询类是否存在根加载器里头,找不到返回null</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">		   <span class="comment">//当c等于空时,则调用自定义加载器</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);<span class="comment">//这里的findClass加载就是上面说的自定义加载器返回的字节</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试String-intern"><a href="#测试String-intern" class="headerlink" title="测试String.intern()"></a>测试String.intern()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当str类调用intern()时,会去访问常量池中有没有这个字符串对象,如已存在会返回常量池中的对象,没有则存放在常量池</span></span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"asc"</span>).intern();</span><br><span class="line">String ss = <span class="string">"asc"</span>;<span class="comment">//当创建字面量时,会去常量池中找有没有asc这个字符串对象，如果有直接返回对应的地址</span></span><br><span class="line">System.out.println(ss==s)<span class="comment">//为true</span></span><br><span class="line"><span class="comment">//false</span></span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"asc"</span>)</span><br><span class="line">String ss = <span class="string">"asc"</span>;</span><br><span class="line"><span class="comment">//当字面量调用intern时</span></span><br><span class="line">String ss = <span class="string">"asc"</span>.intern();<span class="comment">//这里是访问常量池是否有这个字符串对象</span></span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"asc"</span>)<span class="comment">//这里是创建堆中的对象</span></span><br><span class="line"><span class="comment">//页为false</span></span><br></pre></td></tr></table></figure>

<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清理算法"><a href="#标记-清理算法" class="headerlink" title="标记 -清理算法"></a>标记 -清理算法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">标记出需要回收的对象,在标记完成后进行回收对象.回收后的内存区域会出现不连续的内存碎片。</span><br><span class="line">标记采用收集算法,可分为引用计算算法和可达性分析算法</span><br><span class="line">1、引用计算算法,当对象被引用时,计数加一,没有引用时减一。直到为0没有对象进行引用时,将起标记进行回收。</span><br><span class="line">当对象被互相牵引时,对象会发生回收不了。GC并不是采用引用计算算法 </span><br><span class="line">	1、可作为GC Roots 参数的是:</span><br><span class="line">		1、栈帧中变量表中的引用对象</span><br><span class="line">		2、方法区中静态常量的引用对象</span><br><span class="line">		3、方法区中常量的引用对象</span><br><span class="line">		4、本地方法栈的引用对象</span><br><span class="line">2、可达性分析算法.通过GC Roots的对象为起始点,当一个对象到GC roots时没有任何引用链相连,则证明次对象是不可用的</span><br></pre></td></tr></table></figure>

<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将内存区域分成俩块,当gc要进行回收对象的时候,将存活的对象复制到另一块内存块中,当前内存块进行清除掉。</span><br><span class="line">内存块分为eden区和survivor（s0和s1）8：1 另一块s1是复制的那一块是会被浪费掉。</span><br><span class="line">当回收的对象超过百分之10的时候，会启用担保机制,向老年代借内存,将存活对象放到老年代中。</span><br></pre></td></tr></table></figure>

<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标记出需要回收的对象,如何标记回收对象上面已经说了。</span><br><span class="line">标记完成后,将标记的可回收的对象都进行清除,再将存活的对象往一端,这样可以让内存块的空间变为连续的。当遇到需要更大的对象时,有可用的空间存放。</span><br><span class="line">整体就是处理了碎片化空间</span><br></pre></td></tr></table></figure>

<h4 id="分代算法"><a href="#分代算法" class="headerlink" title="分代算法"></a>分代算法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">目前分代算法 分为新生代 和 老年代。</span><br><span class="line">新生代通常采用复制算法,因为存活对象少的话.只需要付出少量存活对象进行复制即可</span><br><span class="line">老年代通常采用的是标记 清除算法和标记 整理算法,因为老年代不能额外的空间进行分配担保</span><br></pre></td></tr></table></figure>

<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><blockquote>
<ol>
<li>串行回收算法：会停止当前所有线程，进行回收垃圾，停顿时间长，吞吐量大，响应时间长</li>
<li>并行回收算法：当多个线程则行串行回收算法，进行垃圾回收，停顿时间长，吞吐量大，用户体验低，不一定在同一cpu上面跑</li>
<li>并发回收算法：多个线程同时进行垃圾回收，吞吐量小，响应快，停顿时间短。</li>
</ol>
</blockquote>
<h4 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">吞吐量优先 收集器</span><br><span class="line">停顿时间越短越适合与用户交互的程序,而高吞吐则可以高效率地利用cup的时间来处理程序的运算任务，主要适合在后台运算而不需要太多交互的任务</span><br><span class="line">可以通过调整吞吐量来降低停顿时间</span><br></pre></td></tr></table></figure>

<h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><p>​    新生代gc（MinorGC）：指发生在新生代进行垃圾回收动作,使用非常频繁，回收速度比较快</p>
<p>​    老年代gc（MajorGC/Full GC）:Major GC 的速度一般会比MinorGC慢10倍以上</p>
<h4 id="对象优先在eden分配"><a href="#对象优先在eden分配" class="headerlink" title="对象优先在eden分配"></a>对象优先在eden分配</h4><ol>
<li>-XX:+PrintGCDetatils 打印收集器日志参数</li>
<li>-XX:SurvivorRatio=8 设置eden区为8:1空间大小 eden为8 survivor为1</li>
<li>-XX:PretenureSizeThreshold 当大于这个值时会直接送入老年代</li>
<li>MaxTenuringThreshold 设置年龄计数，默认为15</li>
<li>HandlePromotionFailure 空间分配担保 </li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">大多情况下,对象在新生代eden区中分配,当eden区空间不足时,会进行minorGc操作.</span><br><span class="line"></span><br><span class="line">当新生代内存区域是10m 老年代也是10m 创建了3个对象为2mb的进入了eden区,随后创建了4mb的对象,发现eden区空间不足了,将进行一次minorGc操作。操作时gc发现survivor区只剩下1mb了，也无法存放这三个对象,只能通过分配担保机制提前转移到老年代中,而4mb的对象既顺利进入了eden区</span><br></pre></td></tr></table></figure>

<h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--PretenureSizeThreshold设置这个值时不能用 mb来代表</span><br><span class="line"></span><br><span class="line">当创建的对象超过这个值时直接分配到老年代</span><br></pre></td></tr></table></figure>

<h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--MaxTenuringThreshold 年龄计数,当超过这个值时将会转移到老年代。</span><br><span class="line"></span><br><span class="line">虚拟机会给每个对象定一个年龄的计算器，如果对象在eden区出生并且发生了minorGC则年龄进行加一,如果设置的<span class="string">'值'</span>为1时将会分配到老年代中。如果这个值是15的话,会查看survivor区是否能存放这个对象,如能存放将会进行转移,年龄进行加一.当到达年龄则晋升为老年代,如果不能被存放,将采用担保机制进行分配到老年代。</span><br></pre></td></tr></table></figure>

<h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--MaxTenuringThreshold 年龄计数</span><br><span class="line">如果在survivor中间中有相同年龄所有对象的大小总和,大于survivor的空间一半,无须等到年龄值到了再进入老年代</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://47.110.124.167/2020/11/26/jvm/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2020/12/08/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            定时任务
          
        </div>
      </a>
    
    
      <a href="/2020/11/05/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">接口和抽象接口的区别</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "",
    app_key: "",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2021
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="叶枫"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i></p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>


<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>



    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=1808492017&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>